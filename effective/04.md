## 确定对象被使用前已先被初始化
- 手动初始化内置类型
- 确保构造函数初始化对象的每一个成员
    - 对象的成员变量的**初始化发生在进入构造函数之前**
    - 使用**成员初值列**initialization list替换赋值动作
    - class 成员变量总是以其**声明次序**被初始化
- 不同编译单元内定义的 non-local static 对象 的初始化次序
    - **local static 对象**：函数内
    - **non-local static 对象**：global对象、namespace作用域中对象、class内对象
    - **编译单元**：产出单一目标文件的源码，一般是单一源码文件+其包含的头文件
    - 这个问题的意思是如果一个编码文件中的一个non-local static 对象的初始化用到了另一个编码文件中的一个non-local static 对象，而这个对象可能还没初始化，因为C++对于定义在不同编译单元内的 non-local static 对象 的初始化次序没有定义
    - 解决办法：**单例模式**的一个常见实现手法
        - 将每个**non-local static 对象**搬到自己的专属函数内，变成一个**local static 对象**，然后由这个函数返回一个reference指向他所包含的对象。
        - C++保证函数内的**local static 对象**会在函数被调用期间，首次遇到该对象定义式时被初始化